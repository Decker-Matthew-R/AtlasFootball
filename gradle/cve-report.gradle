import groovy.json.JsonSlurper

tasks.register('cveReport') {
    description = 'Generate a formatted CVE vulnerability table report'
    group = 'security'
    dependsOn 'dependencyCheckAnalyze'

    doLast {
        def reportFile = file('build/reports/dependency-check-report.json')

        if (!reportFile.exists()) {
            println "‚ùå No CVE report found. Run 'gradle dependencyCheckAnalyze' first."
            throw new GradleException("CVE report not found")
        }

        def vulnerabilities = parseCveReport(reportFile)

        if (vulnerabilities.isEmpty()) {
            println "‚úÖ No CVEs found in dependencies!"
            return
        }

        vulnerabilities = sortBySeverity(vulnerabilities)
        printCveTable(vulnerabilities)

        def criticalCount = vulnerabilities.count { it.severity == 'CRITICAL' }
        def highCount = vulnerabilities.count { it.severity == 'HIGH' }
        def mediumCount = vulnerabilities.count { it.severity == 'MEDIUM' }

        if (criticalCount > 0 || highCount > 0 || mediumCount > 0) {
            throw new GradleException("CVE scan failed: ${criticalCount + highCount + mediumCount} vulnerabilities need to be addressed. See report above for details.")
        }
    }
}

def parseCveReport(reportFile) {
    def jsonContent = new JsonSlurper().parseText(reportFile.text)
    def vulnerabilities = []

    jsonContent.dependencies?.each { dependency ->
        def fileName = dependency.fileName
        def isTransitive = isTransitiveDependency(dependency)
        def currentVersion = extractVersion(fileName, dependency)

        dependency.vulnerabilities?.each { vuln ->
            vulnerabilities << [
                cve: vuln.name ?: 'N/A',
                package: extractPackageName(fileName),
                currentVersion: currentVersion,
                requiredVersion: findRequiredVersion(vuln, currentVersion),
                type: isTransitive ? 'Transitive' : 'Direct',
                severity: vuln.severity ?: 'Unknown',
                cvssScore: vuln.cvssv3?.baseScore ?: vuln.cvssv2?.score ?: 'N/A'
            ]
        }
    }

    return vulnerabilities
}

static def sortBySeverity(vulnerabilities) {
    def severityOrder = ['CRITICAL': 4, 'HIGH': 3, 'MEDIUM': 2, 'LOW': 1, 'Unknown': 0]
    return vulnerabilities.sort { a, b ->
        severityOrder[b.severity] <=> severityOrder[a.severity] ?:
            b.cvssScore.toString() <=> a.cvssScore.toString()
    }
}

def isTransitiveDependency(dependency) {
    def directDeps = configurations.compileClasspath.dependencies
    def fileName = dependency.fileName

    def isDirectlyDeclared = directDeps.any { dep ->
        fileName.contains("${dep.name}-${dep.version}") ||
            fileName.contains("${dep.name}")
    }

    return !isDirectlyDeclared
}

static def extractPackageName(fileName) {
    def name = fileName.substring(fileName.lastIndexOf('/') + 1)
    name = name.replaceAll(/-\d+.*\.(jar|war)$/, '')
    return name
}

static def extractVersion(fileName, dependency) {
    def matcher = fileName =~ /.*-(\d+(?:\.\d+)*(?:-[A-Za-z0-9.-]+)?)\.(jar|war)$/
    if (matcher.find()) {
        return matcher.group(1)
    }

    dependency.evidenceCollected?.versionEvidence?.each { evidence ->
        if (evidence.value && evidence.value.matches(/\d+.*/) && evidence.confidence == 'HIGHEST') {
            return evidence.value
        }
    }

    return 'Unknown'
}

static def findRequiredVersion(vulnerability, currentVersion) {
    def description = vulnerability.description ?: ''
    def references = vulnerability.references?.collect { it.source + ' ' + it.name }?.join(' ') ?: ''
    def searchText = (description + ' ' + references).toLowerCase()

    def fixedVersions = [] as Set

    def fixedVersionPatterns = [
        /(?:fixed in|patched in|resolved in|corrected in)\s+(?:version\s+)?(\d+(?:\.\d+)*(?:\.\d+)*)/,
        /(?:upgrade to|update to)\s+(?:version\s+)?(\d+(?:\.\d+)*(?:\.\d+)*)/,
        /(?:version\s+)(\d+(?:\.\d+)*(?:\.\d+)*)\s+(?:and later|or later|fixes|resolves)/,
        /(?:>=|‚â•)\s*(\d+(?:\.\d+)*)/
    ]

    fixedVersionPatterns.each { pattern ->
        def matcher = searchText =~ pattern
        while (matcher.find()) {
            def version = matcher.group(1)
            if (version && version.matches(/\d+(\.\d+)*(\.\d+)*/)) {
                fixedVersions.add(version)
            }
        }
    }

    if (fixedVersions.size() > 0) {
        def filteredVersions = fixedVersions.findAll { version ->
            isVersionGreater(version, currentVersion)
        }

        def sortedVersions = filteredVersions.sort { a, b ->
            compareVersions(a, b)
        }

        if (sortedVersions.size() > 0) {
            return sortedVersions.first()
        }
    }

    return 'Check CVE details'
}

static def compareVersions(version1, version2) {
    def v1Parts = version1.split('\\.').collect {
        try { Integer.parseInt(it) } catch (NumberFormatException e) { 0 }
    }
    def v2Parts = version2.split('\\.').collect {
        try { Integer.parseInt(it) } catch (NumberFormatException e) { 0 }
    }

    def maxLength = Math.max(v1Parts.size(), v2Parts.size())

    for (int i = 0; i < maxLength; i++) {
        def v1Val = i < v1Parts.size() ? v1Parts[i] : 0
        def v2Val = i < v2Parts.size() ? v2Parts[i] : 0

        if (v1Val != v2Val) return v1Val <=> v2Val
    }

    return 0
}

static def isVersionGreater(version1, version2) {
    def v1Parts = version1.split('\\.').collect {
        try { Integer.parseInt(it) } catch (NumberFormatException e) { 0 }
    }
    def v2Parts = version2.split('\\.').collect {
        try { Integer.parseInt(it) } catch (NumberFormatException e) { 0 }
    }

    def maxLength = Math.max(v1Parts.size(), v2Parts.size())

    for (int i = 0; i < maxLength; i++) {
        def v1Val = i < v1Parts.size() ? v1Parts[i] : 0
        def v2Val = i < v2Parts.size() ? v2Parts[i] : 0

        if (v1Val > v2Val) return true
        if (v1Val < v2Val) return false
    }

    return false
}

def printCveTable(vulnerabilities) {
    println "\n" + "="*140
    println "üîç CVE VULNERABILITY REPORT"
    println "="*140

    def maxCve = Math.max(12, vulnerabilities.collect { it.cve.length() }.max() ?: 12)
    def maxPackage = Math.max(20, vulnerabilities.collect { it.package.length() }.max() ?: 20)
    def maxCurrent = Math.max(12, vulnerabilities.collect { it.currentVersion.length() }.max() ?: 12)
    def maxRequired = Math.max(30, vulnerabilities.collect { it.requiredVersion.length() }.max() ?: 30)
    def maxType = 10
    def maxSeverity = 8
    def maxScore = 6

    def header = String.format(
        "| %-${maxCve}s | %-${maxPackage}s | %-${maxCurrent}s | %-${maxRequired}s | %-${maxType}s | %-${maxSeverity}s | %-${maxScore}s |",
        "CVE", "Package", "Current", "Minimal Fix", "Type", "Severity", "Score"
    )

    println header
    println "|" + "-" * (header.length() - 2) + "|"

    vulnerabilities.each { vuln ->
        def severityColor = getSeverityEmoji(vuln.severity)
        def typeIcon = vuln.type == 'Direct' ? 'üéØ' : 'üîó'

        println String.format(
            "| %-${maxCve}s | %-${maxPackage}s | %-${maxCurrent}s | %-${maxRequired}s | ${typeIcon} %-${maxType-2}s | ${severityColor} %-${maxSeverity-2}s | %-${maxScore}s |",
            vuln.cve,
            truncate(vuln.package, maxPackage),
            vuln.currentVersion,
            vuln.requiredVersion,
            vuln.type,
            vuln.severity,
            vuln.cvssScore
        )
    }

    println "="*140

    printSummary(vulnerabilities)
}

static def getSeverityEmoji(severity) {
    switch(severity?.toUpperCase()) {
        case 'CRITICAL': return 'üî¥'
        case 'HIGH': return 'üü†'
        case 'MEDIUM': return 'üü°'
        case 'LOW': return 'üü¢'
        default: return '‚ö™'
    }
}

static def truncate(text, maxLength) {
    return text.length() > maxLength ? text.substring(0, maxLength - 3) + "..." : text
}

def printSummary(vulnerabilities) {
    def totalVulns = vulnerabilities.size()
    def criticalCount = vulnerabilities.count { it.severity == 'CRITICAL' }
    def highCount = vulnerabilities.count { it.severity == 'HIGH' }
    def mediumCount = vulnerabilities.count { it.severity == 'MEDIUM' }
    def lowCount = vulnerabilities.count { it.severity == 'LOW' }
    def directCount = vulnerabilities.count { it.type == 'Direct' }
    def transitiveCount = vulnerabilities.count { it.type == 'Transitive' }

    println "\nüìä SUMMARY:"
    println "   Total: ${totalVulns} | Critical: ${criticalCount} | High: ${highCount} | Medium: ${mediumCount} | Low: ${lowCount}"
    println "   Direct: ${directCount} | Transitive: ${transitiveCount}"

    if (criticalCount > 0 || highCount > 0) {
        println "\n‚ö†Ô∏è  ACTION REQUIRED: ${criticalCount + highCount} high-priority vulnerabilities found!"
    }

    println "\nüí° TIP: Use 'gradle dependencies --configuration compileClasspath' to trace dependency paths"
    println "="*140 + "\n"
}
